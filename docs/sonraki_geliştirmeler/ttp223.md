# TTP223 Dokunmatik SensÃ¶r Entegrasyonu

TTP223 dokunmatik sensÃ¶r eklemek, FACE1 projenizin etkileÅŸimini Ã¶nemli Ã¶lÃ§Ã¼de artÄ±rmak iÃ§in mÃ¼kemmel bir fikir! Bu sensÃ¶r dÃ¼ÅŸÃ¼k maliyetli, kullanÄ±mÄ± kolay ve projenize fiziksel etkileÅŸim ekleyecektir.

## Entegrasyon PlanÄ±

### 1. DonanÄ±m BaÄŸlantÄ±sÄ±

```
TTP223 SensÃ¶r     Raspberry Pi
-----------     -------------
VCC             3.3V
GND             GND
SIG/OUT         GPIO17 (veya baÅŸka bir GPIO pin)
```

### 2. Yeni ModÃ¼l OluÅŸturma

Mevcut modÃ¼ler yapÄ±nÄ±za uygun ÅŸekilde yeni bir dokunma sensÃ¶rÃ¼ modÃ¼lÃ¼ oluÅŸturalÄ±m:

```python
#!/usr/bin/env python3
"""
===========================================================
# Proje: FACE1 - Raspberry Pi 5 Robot AI iÃ§in YÃ¼z Eklentisi
# Dosya: touch_sensor.py
# AÃ§Ä±klama: TTP223 dokunmatik sensÃ¶rÃ¼ iÃ§in modÃ¼l.
# BaÄŸÄ±mlÄ±lÄ±klar: RPi.GPIO, time, threading, logging
# BaÄŸlÄ± Dosyalar: include/hardware_defines.py

# Versiyon: 0.1.0
# DeÄŸiÅŸiklikler:
# - [0.1.0] Ä°lk sÃ¼rÃ¼m - temel dokunmatik sensÃ¶r desteÄŸi
#
# Yazar: GitHub Copilot
# Tarih: 2025-05-03
===========================================================
"""

import os
import sys
import time
import logging
import threading
from typing import Dict, List, Tuple, Optional, Union, Callable
from pathlib import Path

# Proje dizinini ve include dizinini Python yoluna ekle
PROJECT_DIR = Path(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
sys.path.append(str(PROJECT_DIR))

from include import hardware_defines

# Logger yapÄ±landÄ±rmasÄ±
logger = logging.getLogger("TouchSensor")

# RPi.GPIO'yu koÅŸullu iÃ§e aktarma
try:
    import RPi.GPIO as GPIO
    GPIO_AVAILABLE = True
except ImportError:
    logger.warning("RPi.GPIO kÃ¼tÃ¼phanesi bulunamadÄ±, simÃ¼lasyon modu etkin.")
    GPIO_AVAILABLE = False


class TouchSensor:
    """
    TTP223 dokunmatik sensÃ¶rÃ¼ yÃ¶netir ve dokunma olaylarÄ±nÄ± iÅŸler.
    """

    def __init__(self, config):
        """
        Dokunmatik sensÃ¶r sÄ±nÄ±fÄ±nÄ± baÅŸlatÄ±r
        
        Args:
            config (dict): YapÄ±landÄ±rma ayarlarÄ±
        """
        self.config = config
        self.pin = config.get("hardware", {}).get("touch_sensor", {}).get("pin", 17)
        self.debounce_time = config.get("hardware", {}).get("touch_sensor", {}).get("debounce_time", 0.1)
        self.long_press_time = config.get("hardware", {}).get("touch_sensor", {}).get("long_press_time", 1.0)
        
        # Dokunma olayÄ± geri Ã§aÄŸrÄ±larÄ±
        self.touch_callbacks = []
        self.long_press_callbacks = []
        self.release_callbacks = []
        
        # Durum deÄŸiÅŸkenleri
        self.is_touched = False
        self.touch_start_time = 0
        self.is_running = False
        self.touch_thread = None
        
        # SimÃ¼lasyon modu kontrolÃ¼
        self.simulation_mode = (
            config.get("hardware", {}).get("simulation_mode", False) or 
            not GPIO_AVAILABLE
        )
        
        if self.simulation_mode:
            logger.info("Dokunmatik sensÃ¶r simÃ¼lasyon modu etkin")
        else:
            logger.info(f"Dokunmatik sensÃ¶r pini: GPIO{self.pin}")
    
    def start(self) -> bool:
        """
        Dokunmatik sensÃ¶rÃ¼ baÅŸlatÄ±r
        
        Returns:
            bool: BaÅŸarÄ±lÄ±ysa True
        """
        if self.is_running:
            return True
            
        try:
            if not self.simulation_mode:
                # GPIO modunu ayarla
                GPIO.setmode(GPIO.BCM)
                # Pin modunu ayarla (dahili pull-down)
                GPIO.setup(self.pin, GPIO.IN)
                # Kesme (interrupt) ayarla - hem yÃ¼kselen hem dÃ¼ÅŸen kenar
                GPIO.add_event_detect(self.pin, GPIO.BOTH, callback=self._on_pin_change, bouncetime=int(self.debounce_time * 1000))
            
            # Dokunma kontrolÃ¼nÃ¼ izlemek iÃ§in bir iÅŸ parÃ§acÄ±ÄŸÄ± baÅŸlat
            self.is_running = True
            self.touch_thread = threading.Thread(target=self._touch_monitor_loop, daemon=True)
            self.touch_thread.start()
            
            logger.info("Dokunmatik sensÃ¶r baÅŸlatÄ±ldÄ±")
            return True
            
        except Exception as e:
            logger.error(f"Dokunmatik sensÃ¶r baÅŸlatÄ±lÄ±rken hata: {e}")
            return False
    
    def stop(self) -> None:
        """
        Dokunmatik sensÃ¶rÃ¼ durdurur
        """
        if not self.is_running:
            return
            
        self.is_running = False
        
        if not self.simulation_mode:
            try:
                # GPIO kesme (interrupt) temizleme
                GPIO.remove_event_detect(self.pin)
                # GPIO temizleme (kanalÄ± serbest bÄ±rak)
                GPIO.cleanup(self.pin)
            except Exception as e:
                logger.error(f"GPIO temizlenirken hata: {e}")
        
        # Ä°ÅŸ parÃ§acÄ±ÄŸÄ±nÄ±n durmasÄ±nÄ± bekle
        if self.touch_thread:
            self.touch_thread.join(timeout=1.0)
        
        logger.info("Dokunmatik sensÃ¶r durduruldu")
    
    def simulate_touch(self) -> None:
        """
        SimÃ¼lasyon modunda dokunma olayÄ± simÃ¼le eder
        """
        if not self.simulation_mode:
            logger.warning("Dokunma simÃ¼lasyonu yalnÄ±zca simÃ¼lasyon modunda Ã§alÄ±ÅŸÄ±r")
            return
        
        logger.info("Dokunma simÃ¼le ediliyor")
        self._on_touch()
        
        # 0.5 saniye sonra bÄ±rakma simÃ¼le et
        threading.Timer(0.5, self._on_release).start()
    
    def register_touch_callback(self, callback: Callable) -> None:
        """
        Dokunma olayÄ± iÃ§in geri Ã§aÄŸrÄ± iÅŸlevi kaydeder
        
        Args:
            callback (Callable): Ã‡aÄŸrÄ±lacak iÅŸlev
        """
        self.touch_callbacks.append(callback)
    
    def register_long_press_callback(self, callback: Callable) -> None:
        """
        Uzun dokunma olayÄ± iÃ§in geri Ã§aÄŸrÄ± iÅŸlevi kaydeder
        
        Args:
            callback (Callable): Ã‡aÄŸrÄ±lacak iÅŸlev
        """
        self.long_press_callbacks.append(callback)
    
    def register_release_callback(self, callback: Callable) -> None:
        """
        Dokunma bÄ±rakma olayÄ± iÃ§in geri Ã§aÄŸrÄ± iÅŸlevi kaydeder
        
        Args:
            callback (Callable): Ã‡aÄŸrÄ±lacak iÅŸlev
        """
        self.release_callbacks.append(callback)
    
    def unregister_callback(self, callback: Callable) -> None:
        """
        KayÄ±tlÄ± bir geri Ã§aÄŸrÄ± iÅŸlevini kaldÄ±rÄ±r
        
        Args:
            callback (Callable): KaldÄ±rÄ±lacak iÅŸlev
        """
        if callback in self.touch_callbacks:
            self.touch_callbacks.remove(callback)
        if callback in self.long_press_callbacks:
            self.long_press_callbacks.remove(callback)
        if callback in self.release_callbacks:
            self.release_callbacks.remove(callback)
    
    def _on_pin_change(self, channel) -> None:
        """
        Pin durumu deÄŸiÅŸtiÄŸinde Ã§aÄŸrÄ±lan kesme (interrupt) iÅŸleyicisi
        
        Args:
            channel: DeÄŸiÅŸen GPIO pin numarasÄ±
        """
        if not self.is_running:
            return
            
        value = GPIO.input(self.pin)
        
        if value == 1 and not self.is_touched:
            # Dokunma baÅŸladÄ±
            self._on_touch()
        elif value == 0 and self.is_touched:
            # Dokunma bitti
            self._on_release()
    
    def _on_touch(self) -> None:
        """
        Dokunma olayÄ±nÄ± iÅŸler
        """
        self.is_touched = True
        self.touch_start_time = time.time()
        
        # Dokunma geri Ã§aÄŸrÄ±larÄ±nÄ± Ã§alÄ±ÅŸtÄ±r
        for callback in self.touch_callbacks:
            try:
                callback()
            except Exception as e:
                logger.error(f"Dokunma geri Ã§aÄŸrÄ±sÄ± Ã§alÄ±ÅŸtÄ±rÄ±lÄ±rken hata: {e}")
        
        logger.debug("Dokunma algÄ±landÄ±")
    
    def _on_release(self) -> None:
        """
        Dokunma bÄ±rakma olayÄ±nÄ± iÅŸler
        """
        if not self.is_touched:
            return
            
        self.is_touched = False
        touch_duration = time.time() - self.touch_start_time
        
        # BÄ±rakma geri Ã§aÄŸrÄ±larÄ±nÄ± Ã§alÄ±ÅŸtÄ±r
        for callback in self.release_callbacks:
            try:
                callback(touch_duration)
            except Exception as e:
                logger.error(f"Dokunma bÄ±rakma geri Ã§aÄŸrÄ±sÄ± Ã§alÄ±ÅŸtÄ±rÄ±lÄ±rken hata: {e}")
        
        logger.debug(f"Dokunma bÄ±rakÄ±ldÄ± (sÃ¼re: {touch_duration:.2f}s)")
    
    def _check_long_press(self) -> None:
        """
        Uzun dokunma kontrolÃ¼ yapar
        """
        if not self.is_touched:
            return
            
        current_time = time.time()
        touch_duration = current_time - self.touch_start_time
        
        if touch_duration >= self.long_press_time:
            # Uzun dokunma geri Ã§aÄŸrÄ±larÄ±nÄ± Ã§alÄ±ÅŸtÄ±r
            for callback in self.long_press_callbacks:
                try:
                    callback(touch_duration)
                except Exception as e:
                    logger.error(f"Uzun dokunma geri Ã§aÄŸrÄ±sÄ± Ã§alÄ±ÅŸtÄ±rÄ±lÄ±rken hata: {e}")
            
            logger.debug(f"Uzun dokunma algÄ±landÄ± (sÃ¼re: {touch_duration:.2f}s)")
            # Uzun dokunma algÄ±landÄ±ÄŸÄ±nda dokunma durumunu sÄ±fÄ±rla (tekrar tetiklenmemesi iÃ§in)
            self.is_touched = False
    
    def _touch_monitor_loop(self) -> None:
        """
        Dokunma durumunu sÃ¼rekli izleyen dÃ¶ngÃ¼
        """
        while self.is_running:
            # Uzun dokunma kontrolÃ¼
            self._check_long_press()
            time.sleep(0.1)  # CPU kullanÄ±mÄ±nÄ± azaltmak iÃ§in kÄ±sa bekleme


# Test kodu
if __name__ == "__main__":
    # Loglama yapÄ±landÄ±rmasÄ±
    logging.basicConfig(
        level=logging.DEBUG,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    print("Touch SensÃ¶rÃ¼ Test")
    print("-----------------")
    
    # Test yapÄ±landÄ±rmasÄ±
    test_config = {
        "hardware": {
            "simulation_mode": True,
            "touch_sensor": {
                "pin": 17,
                "debounce_time": 0.1,
                "long_press_time": 1.0
            }
        }
    }
    
    # SensÃ¶r oluÅŸtur
    sensor = TouchSensor(test_config)
    
    # Geri Ã§aÄŸrÄ±larÄ± tanÄ±mla
    def on_touch():
        print("Dokunma algÄ±landÄ±!")
    
    def on_long_press(duration):
        print(f"Uzun dokunma algÄ±landÄ±! ({duration:.2f}s)")
    
    def on_release(duration):
        print(f"Dokunma bÄ±rakÄ±ldÄ±! ({duration:.2f}s)")
    
    # Geri Ã§aÄŸrÄ±larÄ± kaydet
    sensor.register_touch_callback(on_touch)
    sensor.register_long_press_callback(on_long_press)
    sensor.register_release_callback(on_release)
    
    # SensÃ¶rÃ¼ baÅŸlat
    if sensor.start():
        print("SensÃ¶r baÅŸlatÄ±ldÄ±, simÃ¼lasyon modunda dokunmalar test ediliyor...")
        
        # BirkaÃ§ dokunma simÃ¼le et
        for i in range(3):
            sensor.simulate_touch()
            time.sleep(2)
        
        # SensÃ¶rÃ¼ durdur
        sensor.stop()
        print("SensÃ¶r durduruldu.")
    else:
        print("SensÃ¶r baÅŸlatÄ±lamadÄ±!")
```

### 3. Hardware Defines GÃ¼ncellemesi

hardware_defines.py dosyasÄ±na dokunmatik sensÃ¶r ile ilgili temel sabitleri ekleyelim:

```python
# TTP223 dokunmatik sensÃ¶r varsayÄ±lan pini (mevcut kodun uygun bir yerine ekleyin)
DEFAULT_TOUCH_SENSOR_PIN = 17
```

### 4. KonfigÃ¼rasyon GÃ¼ncellemesi

config.json dosyasÄ±na dokunmatik sensÃ¶r yapÄ±landÄ±rmasÄ±nÄ± ekleyelim:

```python
// "hardware" bÃ¶lÃ¼mÃ¼ne ekleyin
"touch_sensor": {
    "enabled": true,
    "pin": 17,
    "debounce_time": 0.1,
    "long_press_time": 1.0
}
```

### 5. Ana KontrolcÃ¼ Entegrasyonu

OLED ve LED kontrolcÃ¼lerinize eklenmek Ã¼zere dokunmatik sensÃ¶r etkileÅŸimleri:

```python
# Touch sensÃ¶rÃ¼nÃ¼ iÃ§e aktar (ilgili import bÃ¶lÃ¼mÃ¼ne)
from .touch_sensor import TouchSensor

# Face Plugin sÄ±nÄ±fÄ±nÄ±n __init__ metoduna ekleyin
self.touch_sensor = TouchSensor(self.config)

# Face Plugin sÄ±nÄ±fÄ±nÄ±n start metoduna ekleyin
# Touch sensÃ¶rÃ¼nÃ¼ baÅŸlat ve geri Ã§aÄŸrÄ±larÄ± kaydet
if self.touch_sensor.start():
    # Dokunma olaylarÄ±nÄ± kaydet
    self.touch_sensor.register_touch_callback(self.on_touch)
    self.touch_sensor.register_long_press_callback(self.on_long_touch)
    self.touch_sensor.register_release_callback(self.on_release)
    logger.info("Dokunmatik sensÃ¶r baÅŸlatÄ±ldÄ±")
else:
    logger.error("Dokunmatik sensÃ¶r baÅŸlatÄ±lamadÄ±")

# Face Plugin sÄ±nÄ±fÄ±na yeni metodlar ekleyin
def on_touch(self):
    """Dokunma algÄ±landÄ±ÄŸÄ±nda Ã§aÄŸrÄ±lÄ±r"""
    logger.info("Dokunma algÄ±landÄ±")
    
    # GÃ¼Ã§ tasarrufundaysa, normal moda geÃ§
    if self.oled_controller.power_mode != "on":
        self.oled_controller.set_power_mode("on")
        return
    
    # Rastgele bir mikro ifade gÃ¶ster
    expressions = ["happy", "surprised", "confused", "calm"]
    rand_expression = random.choice(expressions)
    self.oled_controller.show_micro_expression(rand_expression, 0.5)
    
    # LED efekti de gÃ¶ster
    self.led_controller.set_animation_pattern("sparkle", duration=1.0)

def on_long_touch(self, duration):
    """Uzun dokunma algÄ±landÄ±ÄŸÄ±nda Ã§aÄŸrÄ±lÄ±r"""
    logger.info(f"Uzun dokunma algÄ±landÄ±: {duration:.2f}s")
    
    # Duygu modunu deÄŸiÅŸtir
    emotions = ["happy", "sad", "angry", "surprised", "fearful", "disgusted", "calm", "neutral"]
    current = self.config.get("emotions", {}).get("default_emotion", "neutral")
    
    # Mevcut duygu dÄ±ÅŸÄ±nda rastgele bir duygu seÃ§
    available = [e for e in emotions if e != current]
    new_emotion = random.choice(available)
    
    # Duyguyu ayarla
    self.oled_controller.set_emotion(new_emotion)
    
    # IO Manager Ã¼zerinden event gÃ¶nder (varsa)
    if hasattr(self, "io_manager"):
        self.io_manager.send_event("emotion_changed", {"emotion": new_emotion})

def on_release(self, duration):
    """Dokunma bÄ±rakÄ±ldÄ±ÄŸÄ±nda Ã§aÄŸrÄ±lÄ±r"""
    # KÄ±sa dokunma ise (uzun dokunma zaten iÅŸlendi)
    if duration < self.touch_sensor.long_press_time:
        # GÃ¶z kÄ±rpma efekti gÃ¶ster
        self.oled_controller.blink()
```

### 6. Test Betikleri OluÅŸturma

```python
#!/usr/bin/env python3
"""
FACE1 - Dokunmatik SensÃ¶r Test BetiÄŸi
"""

import time
import logging
import argparse
from src.modules.touch_sensor import TouchSensor

# Loglama yapÄ±landÄ±rmasÄ±
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

# Test yapÄ±landÄ±rmasÄ±
TEST_CONFIG = {
    "hardware": {
        "simulation_mode": False,  # GerÃ§ek donanÄ±m testi iÃ§in False
        "touch_sensor": {
            "pin": 17,
            "debounce_time": 0.1,
            "long_press_time": 1.0
        }
    }
}

def main():
    parser = argparse.ArgumentParser(description="FACE1 Dokunmatik SensÃ¶r Testi")
    parser.add_argument('--sim', action='store_true', help='SimÃ¼lasyon modunda Ã§alÄ±ÅŸtÄ±r')
    args = parser.parse_args()
    
    if args.sim:
        TEST_CONFIG["hardware"]["simulation_mode"] = True
    
    print("==== FACE1 Dokunmatik SensÃ¶r Testi ====")
    print(f"Mod: {'SimÃ¼lasyon' if TEST_CONFIG['hardware']['simulation_mode'] else 'DonanÄ±m'}")
    
    # SensÃ¶r oluÅŸtur
    sensor = TouchSensor(TEST_CONFIG)
    
    # Olay sayaÃ§larÄ±
    touch_count = 0
    long_touch_count = 0
    
    # Geri Ã§aÄŸrÄ±larÄ± tanÄ±mla
    def on_touch():
        nonlocal touch_count
        touch_count += 1
        print(f"ğŸ‘† Dokunma algÄ±landÄ±! (Toplam: {touch_count})")
    
    def on_long_press(duration):
        nonlocal long_touch_count
        long_touch_count += 1
        print(f"ğŸ‘‡ Uzun dokunma algÄ±landÄ±! (SÃ¼re: {duration:.2f}s, Toplam: {long_touch_count})")
    
    def on_release(duration):
        print(f"ğŸ‘‹ Dokunma bÄ±rakÄ±ldÄ±! (SÃ¼re: {duration:.2f}s)")
    
    # Geri Ã§aÄŸrÄ±larÄ± kaydet
    sensor.register_touch_callback(on_touch)
    sensor.register_long_press_callback(on_long_press)
    sensor.register_release_callback(on_release)
    
    # SensÃ¶rÃ¼ baÅŸlat
    if sensor.start():
        print("\nSensÃ¶r baÅŸlatÄ±ldÄ±.")
        print("Dokunmatik sensÃ¶re dokununca olaylar burada gÃ¶sterilecek.")
        print("Ã‡Ä±kmak iÃ§in Ctrl+C tuÅŸlarÄ±na basÄ±n.")
        
        if TEST_CONFIG["hardware"]["simulation_mode"]:
            print("\nSimÃ¼lasyon modunda otomatik dokunmalar test ediliyor...")
            
            try:
                # BirkaÃ§ dokunma simÃ¼le et
                for i in range(5):
                    # Her 5 saniyede bir dokunma simÃ¼le et
                    time.sleep(3)
                    sensor.simulate_touch()
            except KeyboardInterrupt:
                print("\nTest kullanÄ±cÄ± tarafÄ±ndan sonlandÄ±rÄ±ldÄ±.")
        else:
            try:
                # KullanÄ±cÄ± Ã§Ä±kÄ±ÅŸÄ± bekle
                while True:
                    time.sleep(0.1)
            except KeyboardInterrupt:
                print("\nTest kullanÄ±cÄ± tarafÄ±ndan sonlandÄ±rÄ±ldÄ±.")
        
        # SensÃ¶rÃ¼ durdur
        sensor.stop()
        print("SensÃ¶r durduruldu.")
    else:
        print("SensÃ¶r baÅŸlatÄ±lamadÄ±!")

if __name__ == "__main__":
    main()
```

## KullanÄ±m Ã–rnekleri

Touch sensÃ¶rÃ¼ ÅŸu ÅŸekillerde kullanabilirsiniz:

1. **HÄ±zlÄ± EtkileÅŸim:** KÄ±sa dokunuÅŸ iÃ§in mikro ifadeler, gÃ¶z kÄ±rpma veya LED animasyonlarÄ± tetikleyebilirsiniz.

2. **Duygu Durumu DeÄŸiÅŸtirme:** Uzun dokunuÅŸ ile robotun duygu durumunu deÄŸiÅŸtirebilirsiniz (mutlu, Ã¼zgÃ¼n, kÄ±zgÄ±n vb.).

3. **Enerji Tasarrufu KontrolÃ¼:** Ekranlar/LEDler uyku modundaysa, dokunuÅŸ ile uyandÄ±rabilirsiniz.

4. **EtkileÅŸimli Demolar:** ZiyaretÃ§iler dokunduÄŸunda robot tepki verebilir, bÃ¶ylece sergiler veya demolar iÃ§in daha ilgi Ã§ekici olur.

5. **Mod DeÄŸiÅŸtirme:** FarklÄ± uzunluktaki dokunuÅŸlarla (kÄ±sa, orta, uzun) farklÄ± modlar arasÄ±nda geÃ§iÅŸ yapabilirsiniz.

## Fiziksel YerleÅŸim

TTP223 sensÃ¶rÃ¼nÃ¼ ÅŸu konumlarda yerleÅŸtirebilirsiniz:

1. **Ã–n Panel:** KullanÄ±cÄ±larÄ±n gÃ¶receÄŸi ve kolayca eriÅŸebileceÄŸi bir yerde
2. **BaÅŸÄ±n ÃœstÃ¼:** Robotun "kafasÄ±nÄ±n" Ã¼st kÄ±smÄ±nda 
3. **Yan Taraf:** Robotun yÃ¼zÃ¼nÃ¼n yanÄ±nda, kolay eriÅŸim iÃ§in

## SonuÃ§

Bu dokunmatik sensÃ¶r entegrasyonu, FACE1 projenizin kullanÄ±cÄ± etkileÅŸim seviyesini Ã¶nemli Ã¶lÃ§Ã¼de artÄ±racaktÄ±r. BasitÃ§e dokunarak yÃ¼z ifadelerini ve davranÄ±ÅŸlarÄ± deÄŸiÅŸtirmek, projenize canlÄ± ve interaktif bir boyut katacaktÄ±r.